{
  "version": 3,
  "sources": ["../../../../node_modules/isomorphic-ws/browser.js", "../../../../src/error.ts", "../../../../node_modules/uuid/dist/esm-browser/rng.js", "../../../../node_modules/uuid/dist/esm-browser/regex.js", "../../../../node_modules/uuid/dist/esm-browser/validate.js", "../../../../node_modules/uuid/dist/esm-browser/stringify.js", "../../../../node_modules/uuid/dist/esm-browser/v4.js", "../../../../src/serialization.ts", "../../../../src/websocket/client.ts", "../../../../src/lib/index.ts"],
  "sourcesContent": ["// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nmodule.exports = ws\n", "/**\n * General Flayer error\n */\nexport class FlayerError extends Error {}\n\n/**\n * Flayer timeout error\n */\nexport class FlayerTimeoutError extends FlayerError {}\n\n/**\n * Flayer connection error\n */\nexport class FlayerConnectionError extends FlayerError {}\n", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;", "import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;", "import { v4 as uuidv4 } from \"uuid\";\n\n// TODO Buffer is not supported in browsers - should it be supported by serialization?\n\nexport const typeMarkers = {\n  date: \"@Date\",\n  map: \"@Map\",\n  set: \"@Set\",\n  bigint: \"@BigInt\",\n  // buffer: \"@Buffer\",\n  function: \"@Function\",\n  special: \"@SpecialValue\",\n  error: \"@Error\",\n} as const;\n\ntype TypeMarker = typeof typeMarkers[keyof typeof typeMarkers];\n\nfunction isSerialized(value: any) {\n  return (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    Object.values(typeMarkers).includes(value[0])\n  );\n}\n\nfunction mergeFunctionMaps(a: Map<string, Function>, b: Map<string, Function>) {\n  if (!a && !b) {\n    return null;\n  }\n  if (!b) {\n    return a;\n  }\n  if (!a) {\n    return b;\n  }\n  return new Map([...(!a ? [] : Array.from(a)), ...(!b ? [] : Array.from(b))]);\n}\n\nexport function serialize(object: any): {\n  json: string;\n  functionMap: Map<string, Function>;\n} {\n  let functionMap: Map<string, Function> = null;\n  try {\n    const json = JSON.stringify(object, (_, value) => {\n      // Some values (Date, Buffer) are serialized with toJSON _before_ running the replacer, making the values _always_ already serialized..\n      // Replace nested values when found inside an object/array before reaching the actual value.\n      if (\n        typeof value === \"object\" &&\n        !(value instanceof Map) &&\n        !(value instanceof Set) &&\n        // !(value instanceof Buffer) &&\n        value != null\n      ) {\n        // Prevent mutations to the original object by creating a new one\n        const newValue = Array.isArray(value) ? [...value] : { ...value };\n        for (const key in value) {\n          if (value[key] instanceof Date) {\n            newValue[key] = [typeMarkers.date, value[key].toISOString()];\n          }\n          // if (value[key] instanceof Buffer) {\n          //   newValue[key] = [typeMarkers.buffer, value[key].toString(\"base64\")];\n          // }\n        }\n        return newValue;\n      }\n      if (value instanceof Map) {\n        // Serialize the Map contents - add possible new functions to the function map too\n        const serialized = serialize(Array.from(value.entries()));\n        functionMap = mergeFunctionMaps(functionMap, serialized.functionMap);\n        return [typeMarkers.map, serialized.json];\n      }\n      if (value instanceof Set) {\n        // Serialize the Set contents - add possible new functions to the function map too\n        const serialized = serialize(Array.from(value.values()));\n        functionMap = mergeFunctionMaps(functionMap, serialized.functionMap);\n        return [typeMarkers.set, serialized.json];\n      }\n      if (value instanceof Error) {\n        return [typeMarkers.error, value.message];\n      }\n      if (typeof value === \"bigint\") {\n        return [typeMarkers.bigint, value.toString()];\n      }\n      if (typeof value === \"function\") {\n        if (!functionMap) {\n          functionMap = new Map();\n        }\n        const id = uuidv4();\n        functionMap.set(id, value);\n        return [typeMarkers.function, id];\n      }\n      if (typeof value === \"number\" && isNaN(value)) {\n        return [typeMarkers.special, \"NaN\"];\n      }\n      if (value === Infinity) {\n        return [typeMarkers.special, \"Infinity\"];\n      }\n      if (value === -Infinity) {\n        return [typeMarkers.special, \"-Infinity\"];\n      }\n      return value;\n    });\n    return {\n      json,\n      functionMap,\n    };\n  } catch (error) {\n    throw new SerialiationError(error.message);\n  }\n}\n\nexport function deserialize(json: string) {\n  if (json == null) {\n    return null;\n  }\n  try {\n    return JSON.parse(json, (key, value) => {\n      if (!isSerialized(value)) {\n        return value;\n      }\n      const [type, serializedValue] = value as [type: TypeMarker, value: any];\n      switch (type) {\n        case typeMarkers.date:\n          return new Date(serializedValue);\n        case typeMarkers.map:\n          return new Map(deserialize(serializedValue));\n        case typeMarkers.set:\n          return new Set(deserialize(serializedValue));\n        case typeMarkers.error:\n          return new Error(serializedValue);\n        case typeMarkers.bigint:\n          return BigInt(serializedValue);\n        // case typeMarkers.buffer:\n        //   return Buffer.from(serializedValue, \"base64\");\n        case typeMarkers.function:\n          const fn = (...args) => {\n            const functionId = serializedValue;\n            console.log(\"TODO: emit ws message with function id\", functionId);\n          };\n          // Override function name with the key\n          Object.defineProperty(fn, \"name\", { value: key, writable: false });\n          return fn;\n        case typeMarkers.special:\n          switch (serializedValue) {\n            case \"NaN\":\n              return NaN;\n            case \"Infinity\":\n              return Infinity;\n            case \"-Infinity\":\n              return -Infinity;\n            default:\n              return value;\n          }\n        default:\n          // No special deserialization detected - return value as it was\n          return value;\n      }\n    });\n  } catch (error) {\n    throw new Error(\"serialization_error\");\n  }\n}\n\nexport class SerialiationError extends Error {\n  constructor(cause: string) {\n    super(`Serialization failed: ${cause}`);\n  }\n}\n", "import WebSocket, { MessageEvent } from \"isomorphic-ws\";\nimport { FlayerTimeoutError } from \"../error\";\n\n/**\n * Creates a WebSocket client and connects to the provided Flayer server URL.\n * @param url Flayer server URL\n */\nexport async function connect(url: string) {\n  if (!url) {\n    throw new Error(\"No URL provided. Did you forget to configure the client?\");\n  }\n  const ws = new WebSocket(url);\n  // client.connect(url);\n  return new Promise<WebSocket>((resolve, reject) => {\n    ws.addEventListener(\"open\", () => {\n      resolve(ws);\n    });\n    ws.addEventListener(\"error\", (error) => {\n      reject(error);\n    });\n  });\n}\n\nexport async function sendMessage(ws: WebSocket, message: any) {\n  ws.send(JSON.stringify(message));\n}\n\nexport async function waitForMessage(\n  ws: WebSocket,\n  condition: { [key: string]: unknown },\n  timeout?: number\n) {\n  const a = await new Promise<string>((resolve, reject) => {\n    // Set a timeout if it was provided\n    const timeoutHandle =\n      timeout != null\n        ? setTimeout(() => {\n            reject(new FlayerTimeoutError());\n          }, timeout)\n        : null;\n\n    const messageCallback = (message: MessageEvent) => {\n      try {\n        const jsonMessage = JSON.parse(message.data.toString());\n        if (!objectMatchesCondition(jsonMessage, condition)) {\n          return;\n        }\n        // A message matching the condition was received\n        clearTimeout(timeoutHandle);\n        resolve(jsonMessage.data);\n        ws.removeListener(\"message\", messageCallback);\n      } catch (error) {\n        // Non-JSON message - ignore\n      }\n    };\n    ws.addEventListener(\"message\", messageCallback);\n  });\n  return a;\n}\n\n/**\n * Checks if given object contains all expected key-value pairs\n * @param object Object\n * @param condition Condition object\n * @returns Does the object contain all the key-value pairs of the condition?\n */\nfunction objectMatchesCondition(\n  object: { [key: string]: unknown },\n  condition: { [key: string]: unknown }\n) {\n  return Object.keys(condition).every(\n    (key) => object?.[key] === condition[key]\n  );\n}\n", "import { WebSocket } from \"isomorphic-ws\";\nimport { ClientConfig } from \"../config/client-config\";\nimport { FlayerError } from \"../error\";\nimport { deserialize, serialize } from \"../serialization\";\nimport { connect, sendMessage, waitForMessage } from \"../websocket/client\";\n\ndeclare global {\n  interface Window {\n    flayer: {\n      invocationId: number;\n      ws: WebSocket;\n      config: ClientConfig;\n    };\n  }\n}\n\nfunction get<Key extends keyof typeof window[\"flayer\"]>(key: Key) {\n  return window.flayer[key];\n}\n\nfunction set<Key extends keyof typeof window[\"flayer\"]>(\n  key: Key,\n  value: typeof window[\"flayer\"][Key]\n) {\n  if (!window.flayer) {\n    window.flayer = {\n      invocationId: 0,\n      ws: null,\n      config: null,\n    };\n  }\n  window.flayer[key] = value;\n}\n\nexport async function executeFlayerFunction(\n  modulePath: string,\n  functionName: string,\n  args: any[]\n) {\n  let ws = get(\"ws\");\n  if (!ws) {\n    const config = get(\"config\");\n    if (!config) {\n      throw new FlayerError(\"Client not configured\");\n    }\n    ws = await connect(config.url);\n    set(\"ws\", ws);\n  }\n\n  let id = get(\"invocationId\");\n  set(\"invocationId\", id + 1);\n  const { json, functionMap } = serialize(args);\n  sendMessage(ws, {\n    type: \"invocation\",\n    id,\n    modulePath,\n    functionName,\n    data: json,\n  });\n\n  // TODO start event listeners for each function in functionMap\n\n  const result = await waitForMessage(ws, {\n    type: \"callback\",\n    id,\n  });\n  return deserialize(result);\n}\n\n/**\n * Configure the client to use a Flayer sever\n * @param config Client config\n * @returns WebSocket connection\n */\nexport async function configure(config: ClientConfig) {\n  set(\"config\", config);\n  set(\"ws\", await connect(config.url));\n}\n\n// TODO: Context/session functions\n"],
  "mappings": "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",
  "names": []
}
