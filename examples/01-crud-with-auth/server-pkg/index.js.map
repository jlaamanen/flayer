{
  "version": 3,
  "sources": ["../node_modules/isomorphic-ws/browser.js", "../src/error.ts", "../src/websocket/client.ts", "../src/serialization.ts", "../src/client-lib/index.ts"],
  "sourcesContent": ["// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nmodule.exports = ws\n", "/**\n * General Flayer error\n */\nexport class FlayerError extends Error {}\n\n/**\n * Flayer timeout error\n */\nexport class FlayerTimeoutError extends FlayerError {}\n\n/**\n * Flayer connection error\n */\nexport class FlayerConnectionError extends FlayerError {}\n\n/**\n * Flayer configuration error\n */\nexport class FlayerConfigError extends FlayerError {}\n", "import WebSocket, { MessageEvent } from \"isomorphic-ws\";\nimport { FlayerError, FlayerTimeoutError } from \"../error\";\n\n/**\n * Creates a WebSocket client and connects to the provided Flayer server URL.\n * @param url Flayer server URL\n */\nexport async function connect(url: string) {\n  if (!url) {\n    throw new Error(\"No URL provided. Did you forget to configure the client?\");\n  }\n  const ws = new WebSocket(url);\n  return new Promise<WebSocket>((resolve, reject) => {\n    ws.addEventListener(\"open\", () => {\n      resolve(ws);\n    });\n    ws.addEventListener(\"error\", (error) => {\n      reject(error);\n    });\n  });\n}\n\n/**\n * Send any object as JSON via WebSocket\n * @param ws WebSocket\n * @param message Message as any object\n */\nexport async function sendMessage(ws: WebSocket, message: any) {\n  ws.send(JSON.stringify(message));\n}\n\n/**\n * Wait for a message that matches a given key/value condition.\n * @param ws WebSocket\n * @param condition Condition\n * @param timeout Timeout in milliseconds\n */\nexport function waitForMessage(\n  ws: WebSocket,\n  condition: { [key: string]: unknown },\n  timeout?: number\n) {\n  return new Promise<string>((resolve, reject) => {\n    // Set a timeout if it was provided\n    const timeoutHandle =\n      timeout != null\n        ? setTimeout(() => {\n            reject(\n              new FlayerTimeoutError(\n                \"Timeout waiting for function result exceeded\"\n              )\n            );\n          }, timeout)\n        : null;\n\n    const messageCallback = (message: MessageEvent) => {\n      try {\n        const jsonMessage = JSON.parse(message.data.toString());\n        if (!objectMatchesCondition(jsonMessage, condition)) {\n          return;\n        }\n        // A message matching the condition was received\n        if (timeoutHandle != null) {\n          clearTimeout(timeoutHandle);\n        }\n        if (jsonMessage.error) {\n          const SpecifiedError =\n            jsonMessage.error.name === \"FlayerError\" ? FlayerError : Error;\n          const error = new SpecifiedError(jsonMessage.error.message);\n          reject(error);\n        } else {\n          resolve(jsonMessage.data);\n        }\n        ws.removeEventListener(\"message\", messageCallback);\n      } catch (error) {\n        // Non-JSON message - ignore\n      }\n    };\n\n    // Assign the callback to WebSocket listeners\n    ws.addEventListener(\"message\", messageCallback);\n\n    // If connection is closed, remove the callback & reject the promise\n    ws.addEventListener(\"close\", () => {\n      ws.removeEventListener(\"message\", messageCallback);\n      // TODO: Reconsider if this is needed here - it may crash the server if errors are not handled properly in all callbacks\n      // reject(new FlayerError(\"Client disconnected\"));\n    });\n  });\n}\n\n/**\n * Checks if given object contains all expected key-value pairs\n * @param object Object\n * @param condition Condition object\n * @returns Does the object contain all the key-value pairs of the condition?\n */\nfunction objectMatchesCondition(\n  object: { [key: string]: unknown },\n  condition: { [key: string]: unknown }\n) {\n  return Object.keys(condition).every(\n    (key) => object?.[key] === condition[key]\n  );\n}\n", "import { WebSocket } from \"ws\";\nimport { Message } from \"./message\";\nimport { sendMessage, waitForMessage } from \"./websocket/client\";\n\nexport const typeMarkers = {\n  date: \"@Date\",\n  map: \"@Map\",\n  set: \"@Set\",\n  bigInt: \"@BigInt\",\n  regExp: \"@RegExp\",\n  function: \"@Function\",\n  special: \"@SpecialValue\",\n  error: \"@Error\",\n} as const;\n\ntype TypeMarker = typeof typeMarkers[keyof typeof typeMarkers];\n\nfunction isSerialized(value: any) {\n  return (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    Object.values(typeMarkers).includes(value[0])\n  );\n}\n\n// Sequential ID for identifying callback functions\nlet callbackId = 0;\n\n/**\n * Starts a callback listener for \"serialized\" functions\n * @param ws WebSocket\n * @param fn Function\n */\nfunction startCallbackListener(ws: WebSocket, fn: Function) {\n  const id = callbackId++;\n\n  const callback = async (event: MessageEvent) => {\n    // Parse the message and ignore non-relevant messages\n    const message = JSON.parse(event.data) as Message;\n    if (message.type !== \"callback\" || message.id !== id) {\n      return;\n    }\n\n    // Matching message found - deserialize args and invoke the callback function\n    const args = deserialize(message.args, ws);\n    const result = await fn(...args);\n\n    // Send the data back returned from the callback\n    ws.send(\n      JSON.stringify({\n        type: \"callback\",\n        id,\n        data: serialize(result, ws),\n      })\n    );\n  };\n\n  // Assign the callback as a WebSocket event listener\n  (ws as any).addEventListener(\"message\", callback);\n  // On disconnect remove the event listener\n  ws.addEventListener(\"close\", () => {\n    (ws as any).removeEventListener(\"message\", callback);\n  });\n\n  return id;\n}\n\n/**\n * Serializes the given object.\n *\n * If contains functions, starts listening to their invocations via WebSocket.\n *\n * @param object Object to be serialized\n * @param ws WebSocket\n * @returns Serialized string\n */\nexport function serialize(object: any, ws: WebSocket): string {\n  try {\n    const json = JSON.stringify(object, (_, value) => {\n      // Some values (e.g. Date) are serialized with toJSON _before_ running the replacer, making the values _always_ already serialized..\n      // Replace nested values when found inside an object/array before reaching the actual value.\n      if (\n        typeof value === \"object\" &&\n        !(value instanceof Map) &&\n        !(value instanceof Set) &&\n        !(value instanceof RegExp) &&\n        value != null\n      ) {\n        // Prevent mutations to the original object by creating a new one\n        const newValue = Array.isArray(value) ? [...value] : { ...value };\n        for (const key in value) {\n          if (value[key] instanceof Date) {\n            newValue[key] = [typeMarkers.date, value[key].toISOString()];\n          }\n        }\n        return newValue;\n      }\n      if (value instanceof Map) {\n        // Serialize the Map contents - add possible new functions to the function map too\n        const serialized = serialize(Array.from(value.entries()), ws);\n        return [typeMarkers.map, serialized];\n      }\n      if (value instanceof Set) {\n        // Serialize the Set contents - add possible new functions to the function map too\n        const serialized = serialize(Array.from(value.values()), ws);\n        return [typeMarkers.set, serialized];\n      }\n      if (value instanceof RegExp) {\n        return [typeMarkers.regExp, [value.source, value.flags]];\n      }\n      if (value instanceof Error) {\n        return [typeMarkers.error, value.message];\n      }\n      if (typeof value === \"bigint\") {\n        return [typeMarkers.bigInt, value.toString()];\n      }\n      if (typeof value === \"function\") {\n        const id = startCallbackListener(ws, value);\n        return [typeMarkers.function, id];\n      }\n      if (typeof value === \"number\" && isNaN(value)) {\n        return [typeMarkers.special, \"NaN\"];\n      }\n      if (value === Infinity) {\n        return [typeMarkers.special, \"Infinity\"];\n      }\n      if (value === -Infinity) {\n        return [typeMarkers.special, \"-Infinity\"];\n      }\n      return value;\n    });\n    return json;\n  } catch (error) {\n    throw new SerialiationError(\n      error instanceof Error ? error.message : \"Unknown error\"\n    );\n  }\n}\n\n/**\n * Deserializes the given JSON string.\n *\n * If contains functions, wraps them into functions that send a message via WwbSocket.\n *\n * @param json Serialized object as JSON\n * @param ws WebSocket\n * @returns Deserialized object\n */\nexport function deserialize(json: string, ws: WebSocket): any {\n  // Any falsy value -> return the value as-is (null, undefined, false, 0...)\n  if (!json) {\n    return json;\n  }\n  try {\n    return JSON.parse(json, (key, value) => {\n      if (!isSerialized(value)) {\n        return value;\n      }\n      const [type, serializedValue] = value as [type: TypeMarker, value: any];\n      switch (type) {\n        case typeMarkers.date:\n          return new Date(serializedValue);\n        case typeMarkers.map:\n          return new Map(deserialize(serializedValue, ws));\n        case typeMarkers.set:\n          return new Set(deserialize(serializedValue, ws));\n        case typeMarkers.regExp:\n          return new RegExp(serializedValue[0], serializedValue[1]);\n        case typeMarkers.error:\n          return new Error(serializedValue);\n        case typeMarkers.bigInt:\n          return BigInt(serializedValue);\n        case typeMarkers.function:\n          const fn = async (...args: any[]) => {\n            const functionId = serializedValue;\n            sendMessage(ws, {\n              type: \"callback\",\n              id: functionId,\n              args: serialize(args, ws),\n            });\n            // Wait for callback result from the other side\n            const result = await waitForMessage(ws, {\n              type: \"callback\",\n              id: functionId,\n            });\n            return deserialize(result, ws);\n          };\n          // Override function name with the key\n          Object.defineProperty(fn, \"name\", { value: key, writable: false });\n          return fn;\n        case typeMarkers.special:\n          switch (serializedValue) {\n            case \"NaN\":\n              return NaN;\n            case \"Infinity\":\n              return Infinity;\n            case \"-Infinity\":\n              return -Infinity;\n            default:\n              return value;\n          }\n        default:\n          // No special deserialization detected - return value as it was\n          return value;\n      }\n    });\n  } catch (error) {\n    console.error(error);\n    throw new SerialiationError(\n      error instanceof Error ? error.message : \"Unknown error\"\n    );\n  }\n}\n\nexport class SerialiationError extends Error {\n  constructor(cause: string) {\n    super(`Serialization failed: ${cause}`);\n  }\n}\n", "import { WebSocket } from \"isomorphic-ws\";\nimport { ClientConfig } from \"../config/client-config\";\nimport { FlayerConnectionError, FlayerError } from \"../error\";\nimport { deserialize, serialize } from \"../serialization\";\nimport { connect, sendMessage, waitForMessage } from \"../websocket/client\";\n\n/**\n * For internal use only - strip these declarations from generated declarations\n * @internal\n */\ndeclare global {\n  interface Window {\n    flayer: {\n      invocationId: number;\n      ws: WebSocket | null;\n      config: ClientConfig | null;\n    };\n  }\n}\n\nfunction get<Key extends keyof typeof window[\"flayer\"]>(key: Key) {\n  return window.flayer[key];\n}\n\nfunction set<Key extends keyof typeof window[\"flayer\"]>(\n  key: Key,\n  value: typeof window[\"flayer\"][Key]\n) {\n  if (!window.flayer) {\n    window.flayer = {\n      invocationId: 0,\n      ws: null,\n      config: null,\n    };\n  }\n  window.flayer[key] = value;\n}\n\n/**\n * For internal use only - strip this function from generated declarations\n * @internal\n */\nexport async function executeFlayerFunction(\n  modulePath: string,\n  functionName: string,\n  args: any[]\n) {\n  let ws = get(\"ws\");\n  if (!ws || ws.readyState !== ws.OPEN) {\n    const config = get(\"config\");\n    if (!config) {\n      throw new FlayerError(\"Client not configured\");\n    }\n    try {\n      ws = await connect(config.url);\n      set(\"ws\", ws);\n    } catch (error) {\n      throw new FlayerConnectionError(\"Error connecting to server\");\n    }\n  }\n\n  let id = get(\"invocationId\");\n  set(\"invocationId\", id + 1);\n  const data = serialize(args, ws);\n  sendMessage(ws, {\n    type: \"invocation\",\n    id,\n    modulePath,\n    functionName,\n    data,\n  });\n\n  const result = await waitForMessage(ws, {\n    type: \"result\",\n    id,\n  });\n  return deserialize(result, ws);\n}\n\n/**\n * Configure the client to use a Flayer sever\n * @param config Client config\n * @returns WebSocket connection\n */\nexport async function configure(config: ClientConfig) {\n  set(\"config\", config);\n  set(\"ws\", await connect(config.url));\n}\n\n/**\n * Closes/invalidates the current WebSocket connection.\n * Connection will be reopened on the next function invocation.\n */\nexport async function disconnect() {\n  const ws = get(\"ws\");\n  ws?.close();\n  set(\"ws\", null);\n}\n"],
  "mappings": "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",
  "names": ["require_browser", "__commonJSMin", "exports", "module", "ws", "FlayerError", "FlayerTimeoutError", "FlayerConnectionError", "import_isomorphic_ws", "connect", "url", "ws", "WebSocket", "resolve", "reject", "error", "sendMessage", "message", "waitForMessage", "condition", "timeout", "timeoutHandle", "FlayerTimeoutError", "messageCallback", "jsonMessage", "objectMatchesCondition", "SpecifiedError", "FlayerError", "object", "key", "typeMarkers", "isSerialized", "value", "callbackId", "startCallbackListener", "ws", "fn", "id", "callback", "event", "message", "args", "deserialize", "result", "serialize", "object", "_", "newValue", "key", "serialized", "error", "SerialiationError", "json", "type", "serializedValue", "functionId", "sendMessage", "waitForMessage", "cause", "get", "key", "set", "value", "executeFlayerFunction", "modulePath", "functionName", "args", "ws", "config", "FlayerError", "connect", "FlayerConnectionError", "id", "data", "serialize", "sendMessage", "result", "waitForMessage", "deserialize", "configure", "disconnect"]
}
